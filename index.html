<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>酷炫粒子效果</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000000;
            color: #ffffff;
            font-family: sans-serif;
            text-align: center;
        }

        #container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        #ui {
            position: absolute;
            bottom: 30px;
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            z-index: 10;
        }

        #shape-button, #color-picker {
            padding: 10px 20px;
            font-size: 16px;
            border: 2px solid #fff;
            background-color: transparent;
            color: #fff;
            cursor: pointer;
            border-radius: 5px;
            transition: background-color 0.3s, color 0.3s;
            margin: 5px 0;
        }

        #shape-button:hover {
            background-color: #fff;
            color: #000;
        }
        
        #color-picker {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            width: 50px;
            height: 50px;
            border: none;
            background: transparent;
            cursor: pointer;
            padding: 0;
        }
        
        #color-picker::-webkit-color-swatch {
            border: 2px solid #fff;
            border-radius: 50%;
        }
        
        #color-picker::-webkit-color-swatch-wrapper {
            padding: 0;
        }

        .controls-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 20px;
        }
    </style>
</head>
<body>
    <div id="container"></div>
    <div id="ui">
        <div class="controls-group">
            <button id="shape-button">改变形状</button>
            <input type="color" id="color-picker" value="#00ffcc">
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/three@0.137.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.137.0/examples/js/controls/OrbitControls.js"></script>

    <script>
        let scene, camera, renderer, particles, controls;
        const particleCount = 20000;
        const shapes = ['cube', 'sphere', 'pyramid', 'cylinder'];
        let currentShapeIndex = 0;
        let isTransitioning = false;

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 100;

            renderer = new THREE.WebGLRenderer({ antialiasing: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.getElementById('container').appendChild(renderer.domElement);

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;

            // 创建初始的立方体粒子，并设置初始渐变色
            createParticles('cube', new THREE.Color(document.getElementById('color-picker').value));

            window.addEventListener('resize', onWindowResize, false);
            document.getElementById('shape-button').addEventListener('click', changeShape);
            document.getElementById('color-picker').addEventListener('input', changeParticleColor);
        }

        // 创建粒子，并接受一个主色作为参数
        function createParticles(shapeType, baseColor) {
            // 如果已经存在粒子，先移除
            if (particles) {
                scene.remove(particles);
                particles.geometry.dispose();
            }
            
            const geometry = new THREE.BufferGeometry();
            const positions = [];
            const colors = [];
            
            const pMaterial = new THREE.PointsMaterial({
                size: 2,
                vertexColors: true, // 启用顶点颜色
                blending: THREE.AdditiveBlending,
                transparent: true,
                sizeAttenuation: false,
                // **关键修复**：将材质颜色设置为白色，这样它就不会影响顶点颜色。
                color: new THREE.Color(0xffffff) 
            });

            const tempColor = new THREE.Color();
            const hsl = {};

            for (let i = 0; i < particleCount; i++) {
                const x = THREE.MathUtils.randFloatSpread(100);
                const y = THREE.MathUtils.randFloatSpread(100);
                const z = THREE.MathUtils.randFloatSpread(100);
                positions.push(x, y, z);

                baseColor.getHSL(hsl);
                tempColor.setHSL(
                    hsl.h + THREE.MathUtils.randFloat(-0.05, 0.05),
                    hsl.s + THREE.MathUtils.randFloat(-0.2, 0.2),
                    hsl.l + THREE.MathUtils.randFloat(-0.2, 0.2)
                );
                colors.push(tempColor.r, tempColor.g, tempColor.b);
            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            particles = new THREE.Points(geometry, pMaterial);
            scene.add(particles);

            setTargetPositions(shapeType);
        }

        // 改变粒子颜色（生成新的渐变色）
        function changeParticleColor(event) {
            const newBaseColor = new THREE.Color(event.target.value);
            const colors = particles.geometry.attributes.color.array;
            const tempColor = new THREE.Color();
            const hsl = {};
            
            newBaseColor.getHSL(hsl);

            for (let i = 0; i < particleCount; i++) {
                tempColor.setHSL(
                    hsl.h + THREE.MathUtils.randFloat(-0.05, 0.05),
                    hsl.s + THREE.MathUtils.randFloat(-0.2, 0.2),
                    hsl.l + THREE.MathUtils.randFloat(-0.2, 0.2)
                );
                colors[i * 3] = tempColor.r;
                colors[i * 3 + 1] = tempColor.g;
                colors[i * 3 + 2] = tempColor.b;
            }
            particles.geometry.attributes.color.needsUpdate = true;
        }
        
        // 计算不同形状的目标位置 (保持不变)
        function setTargetPositions(shapeType) {
            const targetPositions = [];
            if (shapeType === 'cube') {
                for (let i = 0; i < particleCount; i++) {
                    targetPositions.push(THREE.MathUtils.randFloat(-50, 50), THREE.MathUtils.randFloat(-50, 50), THREE.MathUtils.randFloat(-50, 50));
                }
            } else if (shapeType === 'sphere') {
                for (let i = 0; i < particleCount; i++) {
                    const radius = 50;
                    const phi = Math.acos(2 * Math.random() - 1);
                    const theta = Math.random() * Math.PI * 2;
                    const x = radius * Math.sin(phi) * Math.cos(theta);
                    const y = radius * Math.sin(phi) * Math.sin(theta);
                    const z = radius * Math.cos(phi);
                    targetPositions.push(x, y, z);
                }
            } else if (shapeType === 'pyramid') {
                const height = 100;
                const base = 100;
                for (let i = 0; i < particleCount; i++) {
                    const x = THREE.MathUtils.randFloat(-base / 2, base / 2);
                    const z = THREE.MathUtils.randFloat(-base / 2, base / 2);
                    const y = THREE.MathUtils.randFloat(0, height) - height / 2;
                    if (Math.abs(x) < (base / 2) * (1 - (y + height / 2) / height) && Math.abs(z) < (base / 2) * (1 - (y + height / 2) / height)) {
                        targetPositions.push(x, y, z);
                    } else {
                        i--;
                    }
                }
            } else if (shapeType === 'cylinder') {
                const radius = 50;
                const height = 100;
                for (let i = 0; i < particleCount; i++) {
                    const theta = Math.random() * Math.PI * 2;
                    const x = radius * Math.cos(theta);
                    const z = radius * Math.sin(theta);
                    const y = THREE.MathUtils.randFloat(-height / 2, height / 2);
                    targetPositions.push(x, y, z);
                }
            }
            particles.targetPositions = targetPositions;
        }

        // 改变形状 (保持不变)
        function changeShape() {
            if (isTransitioning) return;
            isTransitioning = true;
            currentShapeIndex = (currentShapeIndex + 1) % shapes.length;
            const nextShape = shapes[currentShapeIndex];
            setTargetPositions(nextShape);

            const positions = particles.geometry.attributes.position.array;
            const targetPositions = particles.targetPositions;

            const scatterPositions = [];
            for (let i = 0; i < particleCount; i++) {
                scatterPositions.push(
                    positions[i * 3] + THREE.MathUtils.randFloatSpread(200),
                    positions[i * 3 + 1] + THREE.MathUtils.randFloatSpread(200),
                    positions[i * 3 + 2] + positions[i * 3 + 2] + THREE.MathUtils.randFloatSpread(200)
                );
            }

            let scatterProgress = 0;
            const scatterDuration = 60;
            const scatterInterval = setInterval(() => {
                const positions = particles.geometry.attributes.position.array;
                const progress = scatterProgress / scatterDuration;
                for (let i = 0; i < particleCount; i++) {
                    positions[i * 3] += (scatterPositions[i * 3] - positions[i * 3]) * 0.1;
                    positions[i * 3 + 1] += (scatterPositions[i * 3 + 1] - positions[i * 3 + 1]) * 0.1;
                    positions[i * 3 + 2] += (scatterPositions[i * 3 + 2] - positions[i * 3 + 2]) * 0.1;
                }
                particles.geometry.attributes.position.needsUpdate = true;
                scatterProgress++;
                if (scatterProgress >= scatterDuration) {
                    clearInterval(scatterInterval);
                    let returnProgress = 0;
                    const returnDuration = 120;
                    const returnInterval = setInterval(() => {
                        const positions = particles.geometry.attributes.position.array;
                        const progress = returnProgress / returnDuration;
                        for (let i = 0; i < particleCount; i++) {
                            positions[i * 3] += (targetPositions[i * 3] - positions[i * 3]) * 0.05;
                            positions[i * 3 + 1] += (targetPositions[i * 3 + 1] - positions[i * 3 + 1]) * 0.05;
                            positions[i * 3 + 2] += (targetPositions[i * 3 + 2] - positions[i * 3 + 2]) * 0.05;
                        }
                        particles.geometry.attributes.position.needsUpdate = true;
                        returnProgress++;
                        if (returnProgress >= returnDuration) {
                            clearInterval(returnInterval);
                            isTransitioning = false;
                        }
                    }, 1000 / 60);
                }
            }, 1000 / 60);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        init();
        animate();
    </script>
</body>
</html>